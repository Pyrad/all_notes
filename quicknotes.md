# Quick Notes

## yyc's GitHub:

[https://github.com/yungyuc](https://github.com/yungyuc)

## Install sphinx (related)

```shell
# 安装sphinx
pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com sphinx
# 安装sphinx_rtd_theme
pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com sphinx_rtd_theme
# 安装markdown支持工具
pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com recommonmark
pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com sphinx_markdown_tables
# 或者只安装Read The Docs网站上推荐的：myst_parser
pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com myst_parser
```

## **labuladong** 算法小抄

[https://labuladong.gitee.io/algo/](https://labuladong.gitee.io/algo/)

# Git for Windows downloads：

官网：https://github.com/git-for-windows/git/releases/

淘宝网镜像：http://npm.taobao.org/mirrors/git-for-windows/

## Github国内镜像

解决Github访问的神器

```
https://github.com.cnpmjs.org/
https://hub.fastgit.org/
https://github.wuyanzheshui.workers.dev/
```

# kernel.org国内镜像

北京交通大学


[https://mirror.bjtu.edu.cn/kernel/linux/kernel/](https://mirror.bjtu.edu.cn/kernel/linux/kernel/)


清华大学

[https://mirror.tuna.tsinghua.edu.cn/kernel/](https://mirror.tuna.tsinghua.edu.cn/kernel/)

南京大学

[https://mirrors.nju.edu.cn/](https://mirrors.nju.edu.cn/)

# How-to ReadTheDoc articles

[https://www.jianshu.com/p/058440ed14df](https://www.jianshu.com/p/058440ed14d)

[https://zhuanlan.zhihu.com/p/380889131](https://zhuanlan.zhihu.com/p/380889131)

# Gitee笔记首页示例

[http://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/object-oriented-vs-procedure-oriented](http://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/object-oriented-vs-procedure-oriented)

# Sphnix + reStructuredText + ReadTheDocs Tutorial

- [Series From youtube](https://www.youtube.com/watch?v=pzzjW0Xv_gk&list=PLPDCBPbzk1AYghqYazE7Cxt3p7edml8I7&index=1)

# 欧路词典词库

[https://mdx.mdict.org/](https://mdx.mdict.org/)

# Github 加速

[github访问加速](https://zhuanlan.zhihu.com/p/75994966?utm_source=wechat_session)

# GitHub Speedup (diff ways)

[Github加速的10种方式](https://www.cnblogs.com/shuangxinyuan/p/15506449.html)

# Compiler Explorer

[gcc.godbolt.org](https://gcc.godbolt.org)

## Use GDB in Geany

[The Geany](https://www.geany.org/)

[https://www.zhihu.com/question/65306462/answer/2603110780](https://www.zhihu.com/question/65306462/answer/2603110780)

# 百度网盘搜索 - 知乎文章

[15个好用的百度网盘搜索引擎 - crystal的文章 - 知乎](https://zhuanlan.zhihu.com/p/60840594)

# Use homebrew mirror URLs from Tsinghua university

[Homebrew / Linuxbrew 镜像使用帮助](https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/)

[Homebrew 国内使用加速](https://www.cnblogs.com/cocowool/p/speedup-homebrew.html)


# Z-library how-to-find

[Pirate Library Mirror](http://pilimi.org/)

[Zlibrary 最新入口](https://find.looks.wang/)

[易书论坛 Zlibrary](https://bbs.yibook.org/)

[Zlibrary Pro Helper](https://zlib.pro/)

https://nav.yibook.org/

https://www.pdfdrive.com/

https://xmsoushu.com/#/

# Add icon for html files generated by sphinx

> Thanks to @StevePiercy I found this documentation: https://www.sphinx-doc.org/en/master/usage/configuration.html#confval-html_favicon
> 
> conf.py
> 
> `html_favicon = 'favicon.ico'`
> 
> I put favicon.ico in my source folder, next to my .rst-files and it is working as expected: https://global-coffee-data-standard.readthedocs.io/en/latest/index.html



# Router OS Software Tutorial - OpenWrt Tutrial

[https://youtu.be/L5XyXAfJhGc?si=-q14mao3WISQ3BCf](https://youtu.be/L5XyXAfJhGc?si=-q14mao3WISQ3BCf)


# Words

At the outset 在开始时：在某个活动、计划或过程的最初阶段或起始点。

harking back to 回想或回到过去的某个事物或时期


# CUDA Doc

[如何学习cuda编程？ - 神经旷野舞者的回答 - 知乎](https://www.zhihu.com/question/62996995/answer/3489398460)

[CUDA C++ Programming Guide](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html)

[CUDA Toolkit Documentation 12.4 Update 1](https://docs.nvidia.com/cuda/)

[CUDA C++ Programming Guide - PDF](https://docs.nvidia.com/cuda/pdf/CUDA_C_Programming_Guide.pdf)


# Flex & Bison by John Levine

[Flex & Bison by John Levine](https://www.cse.scu.edu/~m1wang/compiler/TutorialFlexBison.pdf)

# Cython

[Cython - C-Extensions for Python](https://cython.org/)

[Cython 是什么？为什么会有 Cython？](https://blog.csdn.net/chinesehuazhou2/article/details/125252492)

# Springer Freed Books

[Springer Freed Books (how to get)](https://blog.csdn.net/chinesehuazhou2/article/details/105886797?spm=1001.2014.3001.5502)

# SageMath

[SageMath - A free open-source mathematics software system](https://www.sagemath.org/index.html)

[SageMath - GitHub](https://github.com/sagemath/sage)

# NumPy, Cython and PyTorch convert to each other

[numpy、cupy、pytorch数组对象的相互转换](https://blog.csdn.net/BigerBang/article/details/127904816)

# Linux command htop

Reference link [What exactly do the colors in htop status bars mean? - Stack Exchange](https://serverfault.com/questions/180711/what-exactly-do-the-colors-in-htop-status-bars-mean)

After type the following command to show the process status, you could type `F1` or `h` to see the help doc.

```shell
htop -u myUserName
```

# pybind11：实现ndarray转C++原生数组

[pybind11：实现ndarray转C++原生数组](https://blog.csdn.net/qq_74083422/article/details/134921722)

# PyTorch算子底层源码解读--Tensor

[PyTorch算子底层源码解读--Tensor - 硅仙人的文章 - 知乎](https://zhuanlan.zhihu.com/p/465696096)

[Pytorch 源码阅读 —— Tensor C++相关实现](https://blog.csdn.net/Chris_zhangrx/article/details/119086815)

[pytorch基于intrusive_ptr_target实现的核心数据结构介绍](https://blog.csdn.net/weixin_43969854/article/details/129348171)

[PyTorch项目源码学习（2）——Tensor代码结构初步学习 2024-01-10](https://blog.csdn.net/intmeX/article/details/135509288)

[PyTorch internals May 14, 2019](http://blog.ezyang.com/2019/05/pytorch-internals/)


# Words

on par with 和...（处于）同等水平


# Python code class inherits from a Boost.Python wrapped class to use its base class methods

[Create derived python class from a c++ class using Boost Python - Stack Overflow](https://stackoverflow.com/questions/34404224/create-derived-python-class-from-a-c-class-using-boost-python)

如果 class B 是一个Python实现的 class，而 class A 是由 Boost.Python wrapped 的class。

如果 class B 继承了 class A，并且 在 B 中（或B的object对象）要使用 A 的函数（方法）等，如下写的方法会报错，

```cpp
BOOST_PYTHON_MODULE(libgla) {
    using namespace boost::python;

    // ...

    class_<A_cpp_class>("A", init<>())
            .def("check", &A_cpp_class::check_internal);

    // ...
};
```

```python
class B(A):
  def __init__(self):
    self.foobar = 0

  def debug(self):
    self.check() # <------- Error will be reported !
```

原因是在 B 的初始化函数中，并没有调用 A 的初始化函数，导致 B 并不是一个合法的继承于 A 的class。

所以 B 需要在 Python 中修改如下，

```python
class B(A):
  def __init__(self):
    A.__init__(self)  # <------ Should call A's initialization func
    self.foobar = 0

  def debug(self):
    self.check() # <------- Now it's ok to call methods from the base class (A)
```

# Store C++ pointers as integers

Short : use `std::uintptr_t` instead of `int`, `long`, ...

[Converting a pointer into an integer - Stack Overflow](https://stackoverflow.com/questions/153065/converting-a-pointer-into-an-integer/26586211#26586211)


# Wrapped class by Boost.Python

Boost Python Exposing C++ class with constructor taking a std::list

[Boost Python Exposing C++ class with constructor taking a std::list](https://stackoverflow.com/questions/56290774/boost-python-exposing-c-class-with-constructor-taking-a-stdlist)

# CMake - How to specify include paths

[How to properly add include directories with CMake - Stack Overflow](https://stackoverflow.com/questions/13703647/how-to-properly-add-include-directories-with-cmake)


# Set file type at the end of a file for VIM to identify

## For Python

Set file as a Python file style, setting tabs, spaces, etc

```shell
vim: set ft=python et sw=2 ts=2 sts=2:
```

Pay attention that this line should be commented out in the file to avoid being recoginzed by the python interpreter, thus a symbol `#` should be added to the front of this line.

## For C++

```shell
vim: set ff=unix et sw=3 ts=3 sts=3:
```

Remember to add comment symbol `//` to the front of this line.

# coc-nvim 查看函数定义等快捷键

```vim
" GoTo code navigation
nmap <silent> [f <Plug>(coc-definition)
nmap <silent> [y <Plug>(coc-type-definition)
nmap <silent> [i <Plug>(coc-implementation)
nmap <silent> [r <Plug>(coc-references)
```

# config文件对应的coc snippet文件路径

一般，coc对应的snippet文件是：

`~/.config/coc/ultisnippet/conf.snippets`

# Detect a file as Markdown type

```shell
autocmd BufNewFile,BufFilePre,BufRead *.md set filetype=markdown
```

# 把某个关键字替换成连续递增的整数：

```vim
:%s/x/\=printf("%d", line('.') - 10)/gc
```

# 鼠标闪烁效果

```vim
" Disable all blinking:
:set guicursor+=a:blinkon0
" Remove previous setting:
:set guicursor-=a:blinkon0
" Restore default setting:
:set guicursor&
```

# 为什么要有 PyCapsule

[Python Capsules - Bradly Froehle - ](https://bfroehle.com/2011/07/18/python-capsules/)

看上去就是在一个Python module 中包装一个指针，然后可以在另一个Python module中使用它。

# Linux diff & patch commands

Apply diff from another file

```shell
path_to_file_A $ diff -u file_A file_B > mypatch.txt
path_to_file_A $ patch -p0 < mypatch.txt
```

Apply diff to another file

```shell
path_to_file_A $ diff -u file_B file_A > mypatch.txt
path_to_file_B $ patch -p0 < mypatch.txt
```

# Flex & Bison (2024-06-10)

## CHAPTER 3 Using Bison

### How a Bison Parser Matches Its Input

```yacc
statement: NAME '=' expression

expression: NUMBER '+' NUMBER
            | NUMBER '−' NUMBER
```

在 Bison 中， 一条 rule 由冒号 `:` 分为两部分。

左侧部分（symbol）叫做 left-hand side of the rule ， 即 LHS

右侧部分（symbols）叫做 right-hand side of the rule ， 即 RHS

不同的rule，可以有相同的 left-hand side （LHS） symbol 。

符号 `|` 表示有两条或多条rule有相同的LHS symbol 。

在输入中出现的 symbols ，或由 lex 返回的 symbols ， 叫做 terminal symbols，或 tokens。

而出现在（Bison）rule左侧的LHS symbol，叫做 nonterminal symbol，或 nonterminals。

terminal symbol 和 nonterminal symbol **必须不相同** ，token 不能出现在rule的左侧。

一条 rule 可以直接或间接地引用它自身（递归），从而使得分析较长的语句比较高效。


### Shift/Reduce Parsing

> A bison parser works by looking for rules that might match the tokens seen so far.

Bison parser 是根据当前已经看到的 tokens ， 查询是否有匹配的 rule，并以此进行所谓的 shift 和 reduce。

Bison parser 每次读到一个 token，但没有组成一条完整的 rule 的时候，它就把这个 token
压入到内部维护的一个 stack 里面，然后切换到一个新的、反应刚读到的 token 的 state 上。

这个动作叫做 **shift** 。

当 Bison parser 读到了组成一条完整 rule 右侧（RHS）的所有 symbols 的时候，它就把这些 symbols
从 stack 中都 pop 出来，然后把这条 rule 左侧（LHS）的symbol 压入 stack，同时切换到一个新 state上。

这个动作叫做 **reduction** 。（因为它减少了stack上的item数量）

每当 reduce a rule 的时候，它就会执行rule对应的user code。


这里举例说明如下的表达式是如何被 parse 的。

```cpp
fred = 12 + 13
```

假设有如下的 rule ，

```yacc
statement: NAME '=' expression

expression: NUMBER '+' NUMBER
            | NUMBER '−' NUMBER
```

每次读到一个 token，就会向内部的 stack 中 shift 这个 token ，过程如下，

第一次，读到 token `fred` ， 它是一个 `NAME` ， 但是不能组成一个完整的 rule（RHS），
故向 stack 中压栈（shift），

```cpp
fred
```

第二次，读到 token `=` ，同样地，它和已经在栈中的 token 也不能组成一个完整的 rule（RHS），
故继续向 stack 中压栈（shift），此时栈的内容如下

```cpp
fred =
```

第三次，读到 token `12` ，它是一个 `NUMBER`，同样地，它和已经在栈中的 token 也不能组成一个完整的 rule（RHS），
故继续向 stack 中压栈（shift），此时栈的内容如下

```cpp
fred = 12
```

之后第四次重复了上述的压栈过程（shift），此时栈的内容如下，

```cpp
fred = 12 +
```

当第五次读到 token `13` 时，它自己本身也不是一个完整的rule（RHS），因此先把它压入栈（shift），
此时栈中的内容如下，

```cpp
fred = 12 + 13
```

而这个时候，栈中的内容 `12 + 13` 对应的是下面 rule 的右侧（RHS），

```yacc
expression: NUMBER '+' NUMBER
            | NUMBER '−' NUMBER
```

因此，这个时候就发生了 reduction ，token `12` ， `+` 和 `13` 从栈中弹出，然后使用这个 rule 的
左侧（LHS）的symbol，把它压入栈中，那么此时栈中的内容如下，

```cpp
fred = expression
```

而此时栈中的内容又组成了 rule `statement: NAME '=' expression` 的右侧（RHS）部分，因此又产生了
reduce，把 token `fred` ， `=` ，和 `expression` 再从栈中弹出，然后把这条 rule 的左侧（LHS）的
symbol （这里是 statement）压入栈中，此时栈中的内容如下，

```cpp
statement
```

而这个 symbol 正是开始时的 symbol （ *start symbol* ），因此根据语法，读入的所有输入就是合法的。


#### What Bison’s LALR(1) Parser Cannot Parse

Bison parser 的两种 parse 方法。

- LALR(1)

  Look Ahead Left to Right with a one-token lookahead

- GLR

  Generalized Left to Right


这一节介绍的是 LALR(1) ，第9章介绍 GLR。

LALR 不能 parse 的语法

- 同样的输入，匹配语法树中多个（节点）

- 需要多读入的 token 多于一个的情况。

关于上面提到的第二条，这里举例进行了说明。

比如有如下的 rule ，

```yacc
phrase   : cart_animal AND CART
         | work_animal AND PLOW

cart_animal: HORSE | GOAT

work_animal: HORSE | OX
```

如果有输入 `HORSE AND CART` ，看看会发生什么。

首先，bison parser 读入第一个 token `HORSE` ，因为是 LALR(1)，所以实际上 bison parser
还知道下一个 token 是 `AND`。

此时，当前的 token 是 `HORSE` ，有两条 rule 都符合（`cart_animal` 和 `work_animal`），
但 bison parser 不能区分出来它们，原因是，即使考虑到下一个token是 `AND` ，它们也都是
`HORSE AND` ，并不能区分出来有所不同。

而只有当再多读（考虑）下一个 token `CART` 的时候，bison parser 才能发现它符合第一条 rule
的右侧 `cart_animal AND CART`，从而反推出来 `HORSE` 应该是 `cart_animal` ，而不是 `work_animal`。

但这已经是额外多读了两个 token 了，并不是 LALR(1) 的工作方式（它每次只多读一个 token），所以这种
情况下 bison parser 就不能正确分析了。

为了使得 bison parser 能够区分，可以把第一条 rule 改成如下的形式，

```yacc
phrase   : cart_animal CART
         | work_animal PLOW

cart_animal: HORSE | GOAT

work_animal: HORSE | OX
```

此时输入也需要变成 `HORSE CART`。

这种情况下，bison parser 读入了第一个 token `HORSE`，如果仅仅靠这个 token ，
bison parser 是区分不出来它是 `cart_animal` 还是 `work_animal` 的。

但因为 bison parser 会多读一个 token `CART` ，所以它通过比较就会发现符合第一条 rule
的右侧 symbols `cart_animal CART`，因此就会把 `HORSE` 判定为 `cart_animal`。

栈中的变化，首先是把 `HORSE` 压入栈，此时它组成了rule `cart_animal: HORSE | GOAT` 的 RHS，
因此 `HORSE` 出栈， `cart_animal` 入栈。

再读第二个 token `CART`，它也先入栈，此时栈中的内容就是 `cart_animal CART` ，它符合第一条 rule
的右侧 `phrase   : cart_animal CART` ， 因此 `cart_animal` 和 `CART`都出栈，symbol `phrase` 入栈。



在第7章中，讨论了shift/reduce的更多细节。

关于parse的技术，可以参考 Dick Grune 的 [Parsing Techniques: A Practical Guide](http://www.cs.vu.nl/~dick/PTAPG.html)


### A Bison Parser

和 Flex 相同， bison specification 同样拥有三部分的结构，

- 第一部分是 definition section，定义的是 parser的控制信息，并且设置了parser工作时的环境（变量等）。

- 第二部分包含了 parser 的 rule 。

- 第三部分包含了C代码，这些C代码会被逐字逐句地拷贝到最终的C程序中去。


Bison parser 通过把代码片段，添加到一个标准的框架文件中去，从而生成一个 C 程序。

Bison 中的 rules 会被编译成状态机的数组，每个状态是匹配输入的 token。

每当发生 rule reduce的时候，action 的 `$N` 和 `@N` 被转换为 C 代码，位于函数 `yyparse()` 里面的 switch-case 语句中。


### Abstract Syntax Trees

AST = Abstract Syntax Tree

AST is basically a parse tree that omits the nodes for the uninteresting rules.

AST 基本就是 parse tree 里面，去掉不具备实际意义的node，得到的结果。


### An Improved Calculator That Creates ASTs

bison parser 可以允许 symbol（token 和 nonterminals）关联到一个值上，并且允许定义这个值的类型。

在 Bison specification 的第一部分（definition section），可以使用 `%union` 来定义一些类型，以供 symbol（token & nonterminals）使用。

比如这里定义两种类型 `a` 和 `d` ，分别表示一个 AST 的指针类型，和一个 `double` 类型。

```yacc
%union {
   struct ast *a;
   double d;
}
```

在定义了类型之后，就可以在声明 token 的时候，同时声明这个 token 的类型，这个类型的名称，要放在尖括号中 `< >` 。

但如果不需要使用这个 token 对应的值，那么就可以不需要声明它的类型。

比如，下面的例子中，声明了 `NUMBER` 这个 token 对应一个值，其值的类型是 `double`。而 `EOL` 只是被声明是 token，没有关联一个值。

```yacc
%token <d> NUMBER
%token EOL
```

注意，第一章中提到过，一个 symbol 对应的值（value），在 action 中用 `$$` 表示。

也要注意，如果一个 rule 没有指明显式的 action code，那么Bison parser 会赋予其默认的 action code，即

```cpp
$$ = $1;
```

在 bison 中， `$1` 表示的是 rule的右侧（RHS）出现的第`1`个symbol。

另外，如果不使用一个 nonterminal symbol 的值，那么这个 nonterminal symbol 也可以**不声明**。


#### Literal Character Tokens

单个的char，可以在 lex 中直接当做 token 返回，它对应的 token number 实际上就是它自己的ASCII值。

比如 `"+"` ， 就可以直接返回（`yytext[0]`）。



在声明了 token 的类型之后，在 `flex` 中如果要使用一个输入的匹配 `yylval`，那么就得使用到和 C中`union`一样的语法。

比如，因为已经在 yacc 中声明了 token `NUMBER` 是一个 `<d>` ，即浮点类型，那么 `flex` 在处理时，如果要取得对应的值，
并把这个值设置到 `yylval` 中时，就需要使用 `yylval` 了（bison中可以不用这样写），然后才能返回这个 token `NUMBER`。

```lex
[0-9]+"."[0-9]*{EXP}? | "."?[0-9]+{EXP}? {
											yylval.d = atof(yytext); return NUMBER;
										 }
```

#### Building the AST Calculator

Flex 的输出名字默认是 `lex.yy.c` ，如果要指定新的名字，就需要使用 `-o` 选项，如下，

```shell
flex -oMyLexName.c OriginalLex.l
```

Bison 和 Flex 结合起来编译，可以写成 Mikefile 步骤如下

```makefile
fb3_1: fb3_1.l fb3_1.y fb3_1.h
	bison -d fb3_1.y
	flex -ofb3_1.lex.c fb3_1.l
	cc -o $@ fb3_1.tab.c fb3_1.lex.c fb3_1funcs.c
```

### Shift/Reduce Conflicts and Operator Precedence

这节主要说明的是 Bison 如何处理 shift/reduce conflict。

假如有如下的 rule，

```yacc
%type <a> exp

%%
/* ... */

exp: exp '+' exp { $$ = newast('+', $1,$3); }
	| exp '-' exp { $$ = newast('-', $1,$3);}
	| exp '*' exp { $$ = newast('*', $1,$3); }
	| exp '/' exp { $$ = newast('/', $1,$3); }
	| '|' exp { $$ = newast('|', $2, NULL); }
	| '(' exp ')' { $$ = $2; }
	| '-' exp { $$ = newast('M', $2, NULL); }
	| NUMBER { $$ = newnum($1); }
	;
%%
```

当输入是 `2+3*4` 时，分析如下。

- 首先读入 token `2` ，压入栈（shift），此时它符合最后一条 rule 。

  因此发生 reduce，把刚压入栈的 `2` 弹出，然后压入 nonterminal symbol `exp`。

- 再读入 token `+` ，压入栈（shift），此时没有符合的 rule 。

- 再读入 token `3` ，压入栈（shift），此时 `3` 这个 token 符合最后一条 rule
  （即 `exp: NUMBER {$$ = newnum($1); }`），所以reduce，弹出 `3` ， 压入
  nonterminal symbol `exp`。此时栈中的内容是 `exp + exp`。

到这时候，bison parser 就会产生 shift/reduce conflict。

原因是，因为使用的是 LALR(1) ，此时它已经知道下一个 token 是 `*` 了。

那么此时，它可以直接按照 rule

```yacc
exp: exp '+' exp { $$ = newast('+', $1,$3); }
```

产生reduce，或者，读入下一个 token （即 `*` ），再把 `*` 压入栈，并且等到下次再
遇到 `exp` 的时候，根据 rule

```yacc
exp: exp '*' exp { $$ = newast('*', $1,$3); }
```

再在那时候产生 reduce。

产生这样 reduce/shift 问题的原因是：没有告诉 bison 关于操作符的 **precedence** 和 **associativity** 。

