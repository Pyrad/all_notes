# Quick Notes

## yyc's GitHub:

[https://github.com/yungyuc](https://github.com/yungyuc)

## Install sphinx (related)

```shell
# 安装sphinx
pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com sphinx
# 安装sphinx_rtd_theme
pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com sphinx_rtd_theme
# 安装markdown支持工具
pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com recommonmark
pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com sphinx_markdown_tables
# 或者只安装Read The Docs网站上推荐的：myst_parser
pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com myst_parser
```

## **labuladong** 算法小抄

[https://labuladong.gitee.io/algo/](https://labuladong.gitee.io/algo/)

# Git for Windows downloads：

官网：https://github.com/git-for-windows/git/releases/
淘宝网镜像：http://npm.taobao.org/mirrors/git-for-windows/

## Github国内镜像

解决Github访问的神器
https://github.com.cnpmjs.org/
https://hub.fastgit.org/
https://github.wuyanzheshui.workers.dev/

# kernel.org国内镜像

北京交通大学：https://mirror.bjtu.edu.cn/kernel/linux/kernel/
清华大学：https://mirror.tuna.tsinghua.edu.cn/kernel/
南京大学：https://mirrors.nju.edu.cn/

# vscode

官网：https://code.visualstudio.com/#alt-downloads
官网下载速度有时候快有时候慢。
首先在官网找到需要下载的文件，点击下载。
复制载地址，然后将域名的部分更换为如下内容：
vscode.cdn.azure.cn <--------就是左边这个
例如更新后的地址为：https://vscode.cdn.azure.cn/stable/ea3859d4ba2f3e577a159bc91e3074c5d85c0523/code_1.52.1-1608136922_amd64.deb
这个就是国内的镜像了点开后你会发现速度直接起飞。

# How-to ReadTheDoc articles

https://www.jianshu.com/p/058440ed14df

https://zhuanlan.zhihu.com/p/380889131

# Gitee笔记首页示例

http://hollischuang.gitee.io/tobetopjavaer/#/basics/object-oriented/object-oriented-vs-procedure-oriented

# Sphnix + reStructuredText + ReadTheDocs Tutorial

- [Series From youtube](https://www.youtube.com/watch?v=pzzjW0Xv_gk&list=PLPDCBPbzk1AYghqYazE7Cxt3p7edml8I7&index=1)

# 欧路词典词库

[https://mdx.mdict.org/](https://mdx.mdict.org/)

# Github 加速

[github访问加速](https://zhuanlan.zhihu.com/p/75994966?utm_source=wechat_session)

# How to write a coc.nvim extension

[Sam's world](https://samroeca.com/)

https://samroeca.com/coc-plugin.html#coc-plugin

# GitHub Speedup (diff ways)

[Github加速的10种方式](https://www.cnblogs.com/shuangxinyuan/p/15506449.html)

# Compiler Explorer

[gcc.godbolt.org](https://gcc.godbolt.org)

# Checking the code generated implicitly by the C++ compiler

https://stackoverflow.com/questions/24858014/checking-the-code-generated-implicitly-by-the-c-compiler

# How to make vim for win32 - Yongwei

https://github.com/adah1972/vim/wiki

# Use GDB in Geany

[The Geany](https://www.geany.org/)

https://www.zhihu.com/question/65306462/answer/2603110780

# 百度网盘搜索 - 知乎文章

[15个好用的百度网盘搜索引擎 - crystal的文章 - 知乎](https://zhuanlan.zhihu.com/p/60840594)

# Use homebrew mirror URLs from Tsinghua university

[Homebrew / Linuxbrew 镜像使用帮助](https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/)

[Homebrew 国内使用加速](https://www.cnblogs.com/cocowool/p/speedup-homebrew.html)

# Computational Geometry

https://en.wikipedia.org/wiki/Computational_geometry

[NanoVG](https://github.com/memononen/nanovg)

[你工作中最推荐的 C/C++ 程序库有哪些，为什么？ - chunquedong的回答 - 知乎](https://www.zhihu.com/question/51134387/answer/2664748363)

[你工作中最推荐的 C/C++ 程序库有哪些，为什么？ - 知乎](https://www.zhihu.com/question/51134387)

# Doxygen - How to create a doxygen doc for C++ STL?

https://www.doxygen.nl/manual/external.html

https://en.cppreference.com/w/Cppreference:Archives

https://flcwiki.desy.de/How%20to%20document%20your%20code%20using%20doxygen

# English word check

[linggle](https://linggle.com/)

# Z-library how-to-find

[Pirate Library Mirror](http://pilimi.org/)

[Zlibrary 最新入口](https://find.looks.wang/)

[易书论坛 Zlibrary](https://bbs.yibook.org/)

[Zlibrary Pro Helper](https://zlib.pro/)

https://nav.yibook.org/

https://www.pdfdrive.com/

https://xmsoushu.com/#/

# Word

Floor is yours, it means: You have the right to speak now! Say what you want!

# Add icon for html files generated by sphinx

> Thanks to @StevePiercy I found this documentation: https://www.sphinx-doc.org/en/master/usage/configuration.html#confval-html_favicon
> 
> conf.py
> 
> `html_favicon = 'favicon.ico'`
> 
> I put favicon.ico in my source folder, next to my .rst-files and it is working as expected: https://global-coffee-data-standard.readthedocs.io/en/latest/index.html

# Bentley-Ottmann Sweep line algorithm

[Bentley-Ottmann Sweep line algorithm](https://github.com/ideasman42/isect_segments-bentley_ottmann)

# maxdirsize

[What is maxdirsize](https://kb.netapp.com/onprem/ontap/os/What_is_maxdirsize)

Maxdirsize determines the number of files a directory can hold.

The default value of `maxdirsize` is 320M, which is 320\*1024\*1024=335544320.

# Foreign Function Interface

A foreign function interface (FFI) is a mechanism by which a program written in one programming language can call routines or make use of services written or compiled in another one. An FFI is often used in contexts where calls are made into binary dynamic-link library.

[Foreign Function Interface - Wikipedia](https://en.wikipedia.org/wiki/Foreign_function_interface)

# Python setuptool for automation

[https://www.youtube.com/watch?v=Yt-UF7fNLJE](https://www.youtube.com/watch?v=Yt-UF7fNLJE)

# Makefile to check OS type

```makefile
ifeq ($(OS), Windows_NT)
else
endif
```

# Router OS Software Tutorial - OpenWrt Tutrial

[https://youtu.be/L5XyXAfJhGc?si=-q14mao3WISQ3BCf](https://youtu.be/L5XyXAfJhGc?si=-q14mao3WISQ3BCf)

# GDB Python

## Pretty Printer

为了使用STL的**pretty-printer**，需要把对应版本的gcc目录下面`libstdcxx`拷贝到某个专门给GDB使用的目录，然后在`~/.gdbinit`中加入对应的Python代码以便生效。

比如，把gcc-7.3.0中的`libstdcxx`拷贝到`~/scripts/python.utilities/PythonGdb`中：

```bash
cp -rf ${GCC_DIR}/python/libstdcxx/ ~/scripts/python.utilities/PythonGdb/libstdcxx
```

然后在`~/.gdbinit`中加入如下代码

```python
handle SIG35 noprint nostop

#------------------------------------------------------------
# Import the pretty-printer module from a local backup dir
#------------------------------------------------------------
python
import sys
sys.path.insert(0, '~/scripts/python.utilities/PythonGdb')
from libstdcxx.v6.printers import register_libstdcxx_printers
register_libstdcxx_printers(None)
end
```

## 查看编译GDB时的配置信息(Python)

可以使用`--configuration`参数进行查看

```bash
gdb --configuration
```

## gdb中执行Python script

编写Python script，**并且**以`.py`作为后缀。

然后在gdb中直接source即可

```gdb
(gdb) source myPyCmds.py
```

也可直接在gdb中键入命令`py`，进入Python prompt，输入Python代码结束之后，以`end`结尾并回车，即可执行输入的Python代码。

```gdb
(gdb) py
> import gdb
> val = gdb.Value(0)
> end
(gdb)
```

## 从gdb当前session中的variable创建对应的`gdb.Value` object

gdb提供了Python module `gdb`，可以直接import进来。

使用`gdb`这个module提供的API `parse_and_eval()`，参数是当前gdb session中的变量对应的名字（字符串），返回的值是一个`gdb.Value` object。

```python
cxx_var_name_str = "my_cxx_symbol"
val = gdb.parse_and_eval(cxx_var_name_str )
```

## GDB Pretty-Printer中显示错误的Python stack

在使用pretty-printer的时候，如果发生错误，可能只显示简短的异常信息，例如，

```gdb
(gdb) p uptr_var
$112 = Python Exception <type 'exceptions.TypeError'> expected string or buffer:
```

如果要查看更多信息，需要在gdb中设置`set pyathon print-stack [full|message]`：

```gdb
(gdb) set python print-stack full
```

然后就可以打印并查看更详细的错误信息，

```gdb
(gdb) p overflow_filter
$113 = Traceback (most recent call last):
  File "$TO_GDB_PYTHON_DIR/libstdcxx/v6/printers.py", line 144, in to_string
    if is_specialization_of(impl_type, '__uniq_ptr_impl'): # New implementation
  File "$TO_GDB_PYTHON_DIR/libstdcxx/v6/printers.py", line 108, in is_specialization_of
    return re.match('^std::(%s)?%s<.*>$' % (_versioned_namespace, template_name), type) is not None
  File "$PYTHON_DIR/lib/python2.6/re.py", line 137, in match
    return _compile(pattern, flags).match(string)
TypeError: expected string or buffer
```

可以在查看详细信息之后，把显示方式改回默认值：

```gdb
(gdb) set python print-stack message
```

## GDB Python Pretty-Printer中查看C++变量类型的操作

以`std::unique_ptr`对应的pretty printer为例。

在`$GCC_DIR/python/libstdcxx/v6/printers.py`中，对`std::unique_ptr`有如下对应的Python类处理代码。

```python
class UniquePointerPrinter:
  "Print a unique_ptr"

  def __init__ (self, typename, val):
    self.val = val

  def to_string (self):
    impl_type = self.val.type.fields()[0].type.tag
    if is_specialization_of(impl_type, '__uniq_ptr_impl'): # New implementation
      v = self.val['_M_t']['_M_t']['_M_head_impl']
    elif is_specialization_of(impl_type, 'tuple'):
      v = self.val['_M_t']['_M_head_impl']
    else:
      raise ValueError("Unsupported implementation for unique_ptr: %s" % self.val.type.fields()[0].type.tag)
    return 'std::unique_ptr<%s> containing %s' % (str(v.type.target()), str(v))
```

在函数`to_string()`中，

- `self.val`的类型是`gdb.Value`，它用来表示当前gdb session中一个对应的C/C++ object，这样以便在Python中访问。关于这个类，可以查看gnu gdb手册中*Extending GDB*这一章关于`gdb.Value`类和其上的成员的说明。

- `self.val.type`返回的是一个类型为`gdb.Type`的object。

- `self.val.type.fields()`返回的是一个Python `list` object，其中每个元素都是一个`gdb.Field`的object，可以查看手册中`gdb.Type`的说明。

- `self.val.type.fields()[0]`返回一个`gdb.Field` object

- `self.val.type.fields()[0].type`返回一个`gdb.Field` object上的`type`成员，它也是一个`gdb.Type`类型的对象。

- `self.val.type.fields()[0].type.tag`返回的是这个`gdb.Type`类型的`tag`（实际上就是一个字符串），手册中说它是*The tag name for this type. The tag name is the name after struct, union, or enum in C and C++*，也就是关键字`class`后面那个的名字。
  
  需要注意的是，有时候这个`tag`会返回一个`None`，在`std::unique_ptr`的pretty printer中我就遇到这个问题。这种情况下，我的临时办法是使用`self.val.type.fields()[0].type.name`，它返回的也是一个Python字符串，它类似于这样：`std::unique_ptr<XXXXX>::__tuple_type`。
  
  然后根据这个返回的名字字符串做判断。

# Python magic methods

[Python Special/Magic Methods](https://majianglin2003.medium.com/python-special-methods-afcb795ff985#d3a0)

关于`__setattr__`、`__getattr__`和`__getattribute__`

- `__setattr__(self, attr, value)`
  
  它是encapsulation method，即`.`号运算都会先调用到它。

- `__getattr__(self, attr)`
  
  只有当self上的`attr`不存在时，才会调用这个方法，它是用来当做fallback method来做encapsulation的。

- `__getattribute__(self, attr)`
  
  这个方法在访问`self`的任何attribute的时候都会被调用，使用它时要小心，因为很容易造成无限循环递归。
  
  这个方法比较有用的是，可以控制和屏蔽对某些attribute的访问。因为任何访问attribute的操作都会调用这个函数，所以可以在它里面实现具体的控制和屏蔽逻辑。
  
  [Difference between `__getattr__` and `__getattribute__`](https://stackoverflow.com/questions/3278077/difference-between-getattr-and-getattribute)

# Python `__setattr__` 导致的无限递归问题

参考回答：[maximum recursion depth while using __setattr__ in python new style object?](https://stackoverflow.com/questions/20361340/maximum-recursion-depth-while-using-setattr-in-python-new-style-object)

```python
class foo(object):
  def __init__(self, n):
    self.data = dict()

  def __getattr__(self, attr):
    if not attr in self.data.keys():
      print "[ERROR] Attribute {} not found in dict.".format(attr)
      return None
    else:
      return self.data[attr]

  def __setattr__(self, attr, value):
    self.data[attr] = value

if __name__ == "__main__":
  fval = foo(10)
```

执行上面的代码，会产生如下的无限递归错误

```shell
RuntimeError: maximum recursion depth exceeded
```

原因是，因为实现了magic method `__setattr__`，所以对`foo` class object的任何设置attribute的操作都会调用到它。
因此，在函数`def __init__`中也不例外，也就是说 `self.data = dict()`就调用到这个 `__setattr__`方法。
而在magic method `__setattr__`中，因为此时`self`上还没有`data`这个attribute，所以就要调用`__getattr__`方法（因为它是获取属性的兜底函数）。
而在上面`__getattr__`方法的实现中，又再次使用到了`self.data`这个获取`data`方式，同样地，此时`self`上仍然还没有`data`。
因此，`__getattr__`方法再次被调用（开始递归调用），然后就重复上述的过程，发生了无限递归，最终导致到达递归深度上限而报错。

因此，修改的办法是，在`__init__`函数中，不直接使用`self.data`来初始化这个属性，而是使用`self`的`__dict__`，避免访问一个还没有添加好的属性。

```python
class foo(object):
  def __init__(self, n):
    self.__dict__["data"] = dict()
```

# Build a python package with setup.py in CMake

[Build a python package with setup.py in CMake - Stack Overflow](https://stackoverflow.com/questions/29232614/build-a-python-package-with-setup-py-in-cmake)

